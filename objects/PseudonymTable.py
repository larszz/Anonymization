import logging as log
from typing import List

import common
from exceptions import Logger


class PseudonymTable:
	fieldnames = []
	values = {}
	new_fieldname = None

	use_readable_pseudonyms = False
	index = 0


	def __init__(self, use_readable_pseudonyms=False, fieldnames: List = None, new_fieldname=None):
		if fieldnames is None:
			fieldnames = []
		if isinstance(fieldnames, str):
			self.fieldnames = [fieldnames]
		else:
			self.fieldnames = fieldnames
		self.values = {}
		self.use_readable_pseudonyms = use_readable_pseudonyms
		self.new_fieldname = new_fieldname


	def set_fieldnames(self, fieldnames):
		if len(self.fieldnames) > 0:
			Logger.log_already_set('fieldnames')
			return -1

		if isinstance(fieldnames, list):
			for fn in fieldnames:
				self.fieldnames.append(str(fn))
		else:
			self.fieldnames.append(fieldnames)
		return 1


	# adds the given values to the pseudonym table, combined as a tuple, referencing their pseudonym
	def add_value(self, keys):
		# create a tuple to have multiple values as a combined key for the dict
		key_tuple = self.generate_key_value(keys)

		# skip keys that are already in dict
		if key_tuple in self.values:
			return

		self.values[key_tuple] = self.generate_pseudonym()


	# adds the
	def add_value_from_dataset(self, dataset):
		# check none
		if dataset is None:
			Logger.log_none_type_error('dataset')
			return
		if self.fieldnames is None:
			Logger.log_not_set_yet('fieldnames')
			return

		# add values to a list
		value_list = []
		for fn in self.fieldnames:
			field_value = dataset.get_value(fn)
			# if the inserted value is a list, iterate over every list element and insert it as a string
			if isinstance(field_value, list):
				for val in field_value:
					value_list.append(str(val))
			# if inserted value is not a list, just insert that value as a string
			else:
				value_list.append(str(field_value))

		# add the combined value
		self.add_value(value_list)


	# generate the pseudonyms from given table data
	def build_pseudonyms_from_data(self, datasets: List):
		# check none
		if datasets is None:
			Logger.log_none_type_error('datasets')
			return -1
		if self.fieldnames is None:
			Logger.log_not_set_yet('fieldnames')
			return -1
		# check instance
		if not isinstance(datasets, List):
			Logger.log_instance_error('datasets', 'datasets')
			return -1

		for ds in datasets:
			self.add_value_from_dataset(ds)

		return 1


	# ----------------------------------------------
	# GETTER

	# returns the pseudonym (tuple) for directly given keys
	def get_pseudonym(self, keys):
		key_tuple = self.generate_key_value(keys)
		try:
			return self.values[key_tuple]
		except KeyError as ke:
			log.error(str(ke) + ": Key not found in dictionary!")
			return None


	# tries to find all values in dataset to generate a dictionary key with;
	# if all are present, tries to return the pseudonym matching the key
	def get_pseudonym_from_dataset(self, dataset):
		# check none
		if dataset is None:
			Logger.log_none_type_error('dataset')
			return

		# execute
		key_list = []
		for fn in self.fieldnames:
			value = dataset.get_value(fn)
			if value is None:
				Logger.log_key_not_found_error(fn)
				return None

			# if the fieldvalue is a list, add all subvalues to list
			if isinstance(value, list):
				for subvalue in value:
					key_list.append(subvalue)
			else:
				key_list.append(value)
		return self.get_pseudonym(key_list)


	# returns the new field name of combined fields;
	# if no fieldname set, the name will be generated by combining the fieldnames
	def get_new_fieldname(self):
		if self.new_fieldname is None:
			self.new_fieldname = common.generate_combined_field_name(self.fieldnames)
		return self.new_fieldname


	# ----------------------------------------------
	# HELPER METHODS
	# generates the matching key value to the given keys
	@staticmethod
	def generate_key_value(keys) -> tuple:
		return common.generate_dict_key(keys)


	# generates the pseudonym;
	# depending on if it should be readable, the pseudonyms are either numbered combinations of the fieldnames
	# or a random hex number
	def generate_pseudonym(self):
		output = ''
		if self.use_readable_pseudonyms:
			# return a readable key: combination of all fieldnames with the index as suffix
			for f in self.fieldnames:
				output += str(f) + '_'
			output += str(self.index)
			self.index += 1
		else:
			# output a random hex string with 16 digits
			output += common.get_random_colval()
		return output
